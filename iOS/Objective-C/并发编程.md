## 简介
明确几个概念：

* **进程**：进程是资源拥有单位，同一个进程内的线程共享进程里的资源。

* **线程**：线程是资源分配的最小单元，CPU调度的基本

* **多线程** 多线程是针对单核CPU设计的，目的是是为了让CPU快速的在多个线程之间进行调度。使用多线程可以提高程序执行效率，但开启线程需要一定的内存空间。

* **同步和异步**：同步和异步决定了是否要开启新的线程。同步，在当前的线程中执行任务，不具备开启新现场能力；异步：在新线程中执行任务，具备开启新现场的能力。

* **并行与串行**：决定了任务的执行方式。并行：多个任何并发（同时）执行。串行：一个任务执行完毕后，再执行下一个任务。

* **iOS中只有一个主线程，即UI线程。** 不可将耗时任何放在主线程执行，否则会引起卡顿。

## 分类

### NSTread

直接操作线程对象，需手动管理生命周期，经常使用其来查看当前线程。

### GCD(Grand Central Dispatch)

底层采用C语言编写，较为灵活，可根据徐彤负荷增减线程，性能较好。


### Cocoa NSperation

对GCD的封装，封装对NSOperation，添加到`NSOperationQueue`对象中，注意此Queue非彼Queue，更像是一个`Pool`。


## 死锁
### 串行队列
串行异步中嵌套同步：

```Swift
print(1)
serialQueue.async {
    print(2)
    serialQueue.sync {
        print(3)
    }
    print(4)
}
print(5)
```

以上代码只会打印出 12 ，当执行完 `print(2)` 完后，把 `print(3)` 加入当前串行队列（主队列）中进行执行，但是 `print(3)` 想要执行就得让主队列中的上一个任务执行完毕，但现在上一个任务正在等待 `print(3)` 这个任务执行完，双方都进入列等待状态，死锁产生。

如果是串行同步中嵌套异步，如下代码所示：
```Swift
print(1)
serialQueue.sync {
    print(2)
    serialQueue.async {
        print(3)
    }
    print(4)
}
print(5)
```

这样可以打印出 12345 或 12435 。在此的同步操作相当于是“插队”完成任务，第二段代码中，当执行到 `print(2)` 时，同步代码会立即插入当前主队列中进行执行，剩下 `print(3)` 和 `print(4)` 进行 CPU 争抢，也就是 34 或 43 。但在第一段代码中，当执行到进入到异步代码中，执行 `print(2)` 完后，遇到的是同步操作，该操作会立即插入主队列中进行执行，但此时 `print(3)` 没法执行，因为上一步的异步操作代码还没执行完。**切记，不要在主线程中进行同步操作**